import{lerp,getIntersection}from"./utils.js";class Sensor{constructor(car){this.car=car,this.rayCount=5,this.rayLength=150,this.raySpread=.25*Math.PI,this.rays=[],this.readings=[]}#getReading(ray,roadBorders){let touches=[];if(roadBorders.forEach(border=>{border=getIntersection(ray[0],ray[1],border[0],border[1]);border&&touches.push(border)}),0===touches.length)return null;{roadBorders=touches.map(touch=>e=>e.offset);const minOffset=Math.min(...roadBorders);return touches.find(touch=>touch.offset===minOffset)}}#castRays(){this.rays=[];for(let i=0;i<this.rayCount;i++){var rayAngle=lerp(this.raySpread/2,-this.raySpread/2,1==this.rayCount?.5:i/(this.rayCount-1))+this.car.angle,start={x:this.car.x,y:this.car.y},rayAngle={x:this.car.x-Math.sin(rayAngle)*this.rayLength,y:this.car.y-Math.cos(rayAngle)*this.rayLength};this.rays.push([start,rayAngle])}}update(roadBorders){this.#castRays(),this.readings=[],this.rays.forEach(ray=>{this.readings.push(this.#getReading(ray,roadBorders))})}draw(ctx){this.rays.forEach(ray,i=>{let end=ray[1];this.readings[i]&&(end=this.readings[i]),ctx.beginPath(),ctx.lineWidth=2,ctx.strokeStyle="yellow",ctx.moveTo(ray[0].x,ray[0].y),ctx.lineTo(end.x,end.y),ctx.stroke(),ctx.beginPath(),ctx.lineWidth=2,ctx.strokeStyle="black",ctx.moveTo(ray[1].x,ray[1].y),ctx.lineTo(end.x,end.y),ctx.stroke()})}}export{Sensor};